from django.db import reset_queries      очистить историю запросов

---НАЧАЛО РАБОТЫ С ORM---
python manage.py shell           в терминале и запуск оболочки Django
from women.models import *       импорт моделей
Women.objects.all()              выборка всех записей из таблицы women
Women.objects.all()[:5]          Получить первые пять записей
Women.objects.all()[3:8]         делается отбор на уровне SQL-запросов, что очень эффективно (записи с 4 по 8)

---МЕТОДЫ СОРТИРОВКИ---
Women.objects.order_by('pk')    отсортировать записи по определенному полю
Women.objects.order_by('-pk')   символ минус перед именем поля означает обратный порядок сортировки
Women.objects.all().reverse()   порядок (на противоположный) можно менять с помощью метода reverse()

---СПИСОК ЗАПИСЕЙ ПО ВЫБОРУ---
Women.objects.filter(pk__lte=2)   записи, в которых pk <= 2
Women.objects.get(pk=2)           метод get() для получения строго одной записи

---ОБРАБОТКА ДАННЫХ СВЯЗАННЫХ ТАБЛИЦ---

доступны следующие свойства:
w.title, …, w. is_published – значения полей записи таблицы women;
w.pk, w.id – идентификаторы записи (первичный ключ);
w.cat_id – идентификатор рубрики (внешний ключ);
w.cat – объект класса Category, хранящий данные записи с id = cat_id.

w = Women.objects.get(pk=1)       
w.cat                         cat – это действительно ссылка на экземпляр класса Category
w.cat.name                    для получения связанных данных о категории

---ЗАПРОСЫ С ИСПОЛЬЗОВАНИЕМ ВТОРИЧНОЙ МОДЕЛИ (_set)---
c = Category.objects.get(pk=1)         Сначала прочитаем запись из таблицы category
c.women_set.all()                      прочитаем все связанные с данной категорией посты
c.get_posts.filter(is_published=True)   показать записи, которые опубликованы

---ФИЛЬТРЫ ПОЛЕЙ (lookups)---
Women.objects.filter(pk__gt=2)         для выборки записей с идентификатором больше 2
Women.objects.filter(title__contains='ли')      находить строки по их фрагменту, учитывая регистр букв 
                                                 выдаст список всех женщин, в заголовке у которых присутствует фрагмент «ли»
Women.objects.filter(title__icontains='ЛИ')     фильтр icontains осуществляет поиск без учета регистра символов, НО получим пустой список, т.к.:

СУБД SQLite не поддерживает регистронезависимый поиск для русских символов (вообще, для всех не ASCII-символов), поэтому получаем пустой список. 
Другие СУБД, как правило, отрабатывают все это корректно. 
В случае с латинскими символами в SQLite поиск всегда проходит как регистронезависимый.

Women.objects.filter(pk__in=[2,5,11,12])     фильтр in позволяет указывать через список выбираемые записи по значениям (выбор записи с id равными 2, 5, 11, 12)
Women.objects.filter(pk__in=[2,5,11,12], is_published=True)      Если по условию нужно отработать сразу несколько фильтров, то они указываются через запятую
Women.objects.filter(cat__in=[1, 2])                     можно использовать фильтр in и для внешнего ключа
cats = Category.objects.all()             вместо указания конкретных id записей категорий, можно вначале прочитать нужные рубрики 
Women.objects.filter(cat__in=cats)        подставить их вместо списка

---ИСПОЛЬЗОВАНИЕ КЛАССА Q: И, ИЛИ, НЕ---
специальные операторы:
& - логическое И (приоритет 2);
| - логическое ИЛИ (приоритет 3);
~ - логическое НЕ (приоритет 1).

from django.db.models import Q         импорт
Women.objects.filter(pk__lt=5, cat_id=2)   первичный ключ <= 5, рубрика = 2
Women.objects.filter(Q(pk__lt=5) | Q(cat_id=2))     id<5 или cat_id=2
Women.objects.filter(Q(pk__lt=5) & Q(cat_id=2))     
Women.objects.filter(~Q(pk__lt=5) | Q(cat_id=2))    если перед классом прописать тильду, то условие превратится в обратное

---БЫСТРОЕ ПОЛУЧЕНИЕ ЗАПИСИ ИЗ ТАБЛИЦЫ---
Women.objects.first()        зять первую запись из выборки
Women.objects.order_by('pk').first()        выбирать разные записи
Women.objects.order_by('-pk').first()
Women.objects.order_by('pk').last()        для выбора последней записи из набора
Women.objects.filter(pk__gt=5).last()

---ПОЛУЧЕНИЕ ЗАПИСИ ПО ДАТЕ, методы latest и earliest---
latest() – выбор записи с самой поздней датой (наибольшей);
earliest() – выбор записи с самой ранней датой (наименьшей).

Women.objects.earliest('time_update')    самая ранняя запись
Women.objects.latest('time_update')      самая поздняя

Women.objects.order_by('title').earliest('time_update') сделана выборка с сортировкой по какому-либо другому полю (не time_update) 
                                                             и из этой выборки нужно получить самую раннюю или самую позднюю запись


---ВЫБОР ЗАПИСИ ОТНОСИТЕЛЬНО ТЕКУЩЕЙ (ПО ДАТЕ)---
Если нужно выбрать предыдущую или следующую запись относительно текущей, то в ORM для этого существует два специальных метода, 
которые выбирают записи опять же по указанному полю с датой и временем
w = Women.objects.get(pk=7)      
w.get_previous_by_time_update()       для получения предыдущей записи относительно текущей

time_update – это название поля, по которому определяется предыдущая запись

w.get_next_by_time_update()        для получения следующей записи относительно текущей
w.get_next_by_time_update(pk__gt=10)        можно указывать условия выборки следующей или предыдущей записи(выбирается следующая запись с id больше 10)


---МЕТОДЫ exists и count---
В ORM Django имеются два весьма полезных метода с высокой скоростью исполнения:
exists() – проверка существования записи;
count() – получение числа записей.

Если добавить новую категорию(pk=10) и обратиться к ней:
c3 = Category.objects.get(pk=10)
c3.women_set.exists()                   False

c2 = Category.objects.get(pk=2)
c2.women_set.exists()                   True

c2.women_set.count()          получить число записей
Women.objects.filter(pk__gt=4).count()


---ВЫБОРКА ЗАПИСЕЙ ПО ПОЛЯМ СВЯЗАННЫХ МОДЕЛЕЙ---
Women.objects.filter(cat__slug='aktrisy')       все записи из модели Women для определенной категории, используя слаг
Women.objects.filter(cat__in=[1])               
Women.objects.filter(cat__name='Певицы')
Women.objects.filter(cat__name__contains='ы')     выберем записи, у которых имя категории содержит букву ‘ы’
Women.objects.filter(cat__name__contains='цы')
Category.objects.filter(women__title__contains='ли') выбрать все категории, которые связаны с записями вторичной модели Women, 
                                                       содержащие в заголовке фрагмент строки «ли»
Category.objects.filter(women__title__contains='ли').distinct()      отобрать только уникальные записи (категории) 

---АГРЕГИРУЮЩИЕ ФУНКЦИИ---
Women.objects.count()        число записей в таблице women
Women.objects.aggregate(Min('cat_id'))     агрегирующие команды обычно прописываются в специальном методе aggregate()
нужно их импортировать
from django.db.models import *
Women.objects.aggregate(Min('cat_id'), Max('cat_id'))
Women.objects.aggregate(cat_min=Min('cat_id'), cat_max=Max('cat_id'))         Если по каким-либо причинам стандартные ключи нам не подходят
Women.objects.aggregate(res=Sum('cat_id') - Count('cat_id'))       С агрегирующими значениями можно выполнять различные математические операции
Women.objects.aggregate(res=Avg('cat_id'))
Women.objects.filter(pk__gt=4).aggregate(res=Avg('cat_id'))    агрегация выполняется не для всех записей, а только для тех, у которых id больше 4

---ВЫБОР ЗАПИСИ КОНКРЕТНЫХ ПОЛЕЙ (метод values)---
Women.objects.values('title', 'cat_id').get(pk=1)      для указания нужных полей в выборке, используется метод values() с указанием названий полей
Women.objects.values('title', 'cat__name').get(pk=1)     если взять данные из связанной таблицы для имени категории, то Django сформирует запрос 
                                                                     с использованием оператора JOIN SQL-запроса
w = Women.objects.values('title', 'cat__name')      выбираются все нужные данные
for p in w:                                         список
     print(p['title'], p['cat__name'])
     
---ГРУППИРОВКА ЗАПИСЕЙ (метод annotate)---
вызов агрегирующих функций применяется не ко всем записям, а к группам, сформированным по определенному полю
в таблице Women можно сгруппировать записи по cat_id и получим две независимые группы записей
Затем, к каждой группе применить агрегацию и получить искомые значения

1) Women.objects.values('cat_id').annotate(Count('id'))    подсчитать число постов для каждой группы категорий
2) не видим ожидаемого результата
группировка также выполнилась по полям title и time_create. Это связано с тем, что в модели Women во вложенном классе Meta прописана сортировка по этим полям:
3) ordering = ['-time_create', 'title']   Поставим эту строчку в комментарий, выйдем из оболочки Django, снова зайдем, 
4) импортируем необходимые модули
from women.models import *
from django.db.models import *
from django.db import connection
5) повторим команду
Women.objects.values('cat_id').annotate(Count('id'))
видим две группы и для каждой подсчитано число статей. 
6) Можно изменить имя параметра id__count на total
Women.objects.values('cat_id').annotate(total=Count('id'))

метод annotate() используется для вызова агрегирующих функций в пределах групп
Women.objects.annotate(Count('cat'))     получим просто все записи (так как группировка будет выполняться для всех полей)
Category.objects.annotate(Count('women'))        получим все рубрики, но в каждом объекте списка будет атрибут:
c = _                                содержащий число записей для текущей рубрики
c[0].women__count
можно прописывать другие методы, для отбора этих рубрик по значению агрегатной функции:
c = Category.objects.annotate(total=Count('women')).filter(total__gt=0)    отбираются все категории, в которых более нуля записей, то есть, есть хотя бы одна запись

---КЛАСС F---
from django.db.models import F       импорт
Women.objects.filter(pk__gt=F('cat_id'))    Получим все записи, кроме первой (с id=1)

Часто подобные операции приходится делать, когда нужно увеличить, например, счетчик просмотра страниц. Если предположить, что в нашей таблице 
women есть поле views для числа просмотров, то при каждом посещении страницы, мы могли бы увеличивать его значение на 1, следующим образом:
Women.objects.filter(slug='bejonse').update(views=F('views')+1)         При посещении страницы со слагом 'bejonse' произойдет увеличение ее считчика на 1
Или, бывает удобно делать так:
w = Women.objects.get(pk=1)
w.views = F('views')+1
w.save()


---ОРГАНИЗАЦИЯ ВЫЧИСЛЕНИЙ НА УРОВНЕ СУБД---
Django содержит набор функций, позволяющие выполнять вычисления, связанные с полями таблицы, на стороне СУБД
Использование этих функций является рекомендуемой практикой, т.к. СУБД оптимизировано для их выполнения

from django.db.models.functions import Length        использование функции Length для вычисления длины строки
ps = Women.objects.annotate(len=Length('title'))        аннотируем новое вычисляемое поле (для заголовков статей)
for item in ps:
     print(item.title, item.len)                     выведем заголовок и его длину
     
     
---RAW SQL---
когда уровня ORM Django недостаточно, всегда можно перейти на уровень SQL-запросов и записать свой для конкретной используемой СУБД
В простейшем варианте выполнить непосредственно SQL-запрос можно через метод:
Manager.raw(<SQL-запрос>)

Women.objects.raw('SELECT * FROM women_women')     На выходе получаем объект RawQuerySet, содержащий данные выборки
w = _
for p in w:
     print(p.pk, p.title)
     
     
тот же самый результат увидим и при использовании класса модели Category:
w = Category.objects.raw('SELECT * FROM women_women')

модель не имеет особого значения, мы с ее помощью просто обращаемся к менеджеру записей (objects), чтобы выполнить метод raw() для запуска SQL-запроса

метод raw() имеет несколько нюансов в своей работе. 
1) Первый из них – это «ленивое» исполнение запроса, 
то есть, отложенная загрузка информации до момента первого обращения к ней
w = Women.objects.raw('SELECT * FROM women_women')
никакого SQL-запроса выполнено не будет. До тех пор, пока мы не попытаемся что-либо прочитать из переменной w:
w[0].pk                           один выполненный запрос

2) Второй нюанс связан с тем, что при выборке конкретных полей в команде SELECT мы обязаны всегда указывать поле id
w = Women.objects.raw('SELECT id, title FROM women_women')     Без id метод raw() выдаст исключение
несмотря на то, что мы указали в SELECT всего два поля, мы, тем не менее, через ссылку w можем обратиться к любому другому:
w[0].is_published
сработал механизм отложенной загрузки полей и при обращении к конкретному, не указанному ранее полю, происходит дополнительное обращение к БД для его получения


3) возможность передавать параметры в SQL-запрос:
Women.objects.raw("SELECT id, title FROM women_women WHERE slug='shakira'")   выбрать запись по ее слагу
slug = 'shakira'        лучше объявить переменную
Women.objects.raw("SELECT id, title FROM women_women WHERE slug='" + slug + "'")
это прямой путь к SQL-инъекциям, когда злоумышленник вместо слага запишет фрагмент SQL-запроса и прочитает данные из БД.
Поэтому правильно будет использовать механизм параметров в таких raw-запросах
Women.objects.raw("SELECT id, title FROM women_women WHERE slug='%s'", [slug])

from django.db import reset_queries      очистить историю запросов
